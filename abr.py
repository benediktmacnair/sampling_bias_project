# -*- coding: utf-8 -*-
"""ABR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vmqWYWkj9V8uByi8DQtxJ3pqkAdMDo0N
"""

class ABR(Metric):
    '''
    Acceptance-Based Risk (ABR): classification error rate on accepted applicants,
    averaged over a range of acceptance rates.
    '''
    def __call__(self,
                 y_true: Union[np.ndarray, pd.Series],
                 y_pred: np.ndarray,
                 y_proba: np.ndarray,
                 **kwargs) -> float:
        # Acceptance rate range (e.g., 20%â€“40%)
        acc_rate: list = kwargs.get('acc_rate', [0.2, 0.4])
        alphas = np.linspace(acc_rate[0], acc_rate[1], num=10)
        abrs = []

        # Safety check
        assert len(y_true) == len(y_pred) == len(y_proba), "Input arrays must have the same length."

        # Use predicted probability of BAD class (class 1)
        y_proba_positive = y_proba[:, 1] if y_proba.ndim == 2 else y_proba

        for alpha in alphas:
            # Accept lowest alpha% of predicted BADs = safest applicants
            sorted_indices = np.argsort(y_proba_positive)
            n_selected = int(len(y_proba_positive) * alpha)
            selected = sorted_indices[:n_selected]

            # Get true and predicted labels for accepted applicants
            y_true_sel = y_true[selected] if isinstance(y_true, np.ndarray) else y_true.iloc[selected]
            y_pred_sel = y_pred[selected]

            # Compute ABR = classification error rate
            abr = np.mean(y_true_sel != y_pred_sel)
            abrs.append(abr)

        return np.mean(abrs)